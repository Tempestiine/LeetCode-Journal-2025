\# ðŸ§® Problem: Two Sum



\[Two Sum - LeetCode](https://leetcode.com/problems/two-sum/description/?source=submission-ac)



\*\*LeetCode 1\*\*



\*\*Accuracy\*\*: 55.9%



\*\*Tags\*\*: Array, Hash Table



\*\*Time\*\*: 6/19/2025, 7/16/2025



---



\### ðŸ”— Problem Description



Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.



You may assume that each input would have exactly one solution, and you may not use the same element twice.



You can return the answer in any order.





\*\*Example 1:\*\*  

Input: `nums = \[2,7,11,15], target = 9`

Output: `\[0,1]`

Explanation: `Because nums\[0] + nums\[1] == 9, we return \[0, 1].`



\*\*Constraints:\*\*



\- `2 <= nums.length <= 10^4`

\- `-10^9 <= nums\[i], target <= 10^9`

\- \*Only one valid answer exists.\*



---



\### ðŸ§  My Thought Process \[PT. 1]



Through brute force, I wanted to check every combination of numbers and see if any pairs added up to the target value.



---



\### ðŸ§ª Code (Java) \[PT. 1, ACCEPTED]



```java

class Solution {

&nbsp;   public int\[] twoSum(int\[] nums, int target) {

&nbsp;       int x = 0, y = 0;

&nbsp;       OUT : for (x = 0;x < nums.length - 1; x++)

&nbsp;           for (y = x + 1; y < nums.length; y++)

&nbsp;               if (nums\[x] + nums\[y] == target)

&nbsp;                   break OUT;

&nbsp;       return new int\[] {x, y};

&nbsp;   }

}

```

---



\### ðŸ§  My Thought Process \[PT. 2]



To my surprise, LeetCode said that I could have saved much more space and time (45 ms, 44.9 MB). I referred to the Editorial (LeetCode).



A HashTable can reduce the lookup time from O(n) to O(1) by trading space for speed. It supports fast lookup in near constant time. This implies that I must use keys to access values in the HashTable, and LeetCode suggested using the complements of an element as keys. I adapted my code to their advice.



---



\### ðŸ§ª Code (Java) \[PT. 2, ACCEPTED]



```java

class Solution {

&nbsp;   // Lookup time can be reduced with HashTables (LeetCode)

&nbsp;   public int\[] twoSum(int\[] nums, int target) {

&nbsp;       // Creating a HashMap

&nbsp;       Map<Integer, Integer> map = new HashMap<Integer, Integer>();

&nbsp;       for (int i = 0; i < nums.length; i++)

&nbsp;           map.put(nums\[i], i);

&nbsp;       // Finding two elements

&nbsp;       int complement;

&nbsp;       for (int x = 0; x < nums.length; x++) {

&nbsp;           complement = target - nums\[x];

&nbsp;           if (map.containsKey(complement) \&\& map.get(complement) != x)

&nbsp;               return new int\[] {x, map.get(complement)};

&nbsp;       }

&nbsp;       return new int\[0];

&nbsp;   }

}

```



---



\### ðŸ§  My Thought Process \[PT. 3]



I wanted the method to use only one loop, and I was glad that the Editorial had the same idea. I changed my code.



---



\### ðŸ§ª Code (Java) \[FINAL, ACCEPTED]



```java

class Solution {

&nbsp;   // Lookup time can be reduced with HashTables (LeetCode)

&nbsp;   public int\[] twoSum(int\[] nums, int target) {

&nbsp;       Map<Integer, Integer> map = new HashMap<Integer, Integer>();

&nbsp;       int complement;

&nbsp;       Integer index;

&nbsp;       for (int i = 0; i < nums.length; i++) {

&nbsp;           complement = target - nums\[i];

&nbsp;           index = map.get(complement);

&nbsp;           if (index != null)

&nbsp;               return new int\[] {i, map.get(complement)};

&nbsp;           map.put(nums\[i], i);

&nbsp;       }

&nbsp;       return new int\[0];

&nbsp;   }

}

```



---



\### ðŸ§  Reflection



* Wow! I went down to 2 ms of Runtime and 44.8 MB. My runtime has decreased significantly.
* Next time, I'll take advantage of HashMaps more. 









